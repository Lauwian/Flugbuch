<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>OCR Flugbuch (mit Bild-Preprocessing)</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 600px; margin: auto; }
    #output { white-space: pre-wrap; background: #f8f8f8; padding: 12px; margin-top: 20px; border-radius: 5px; border: 1px solid #ddd; }
    canvas { display: none; }
  </style>
</head>
<body>
  <h2>OCR Flugbuch (mit Bild-Optimierung)</h2>
  <input type="file" id="imageInput" accept="image/*"><br><br>
  <progress id="progress" value="0" max="1" style="width: 100%;"></progress>
  <div id="output">Bitte Bild hochladenâ€¦</div>
  <canvas id="canvas"></canvas>

  <script>
    const imageInput = document.getElementById('imageInput');
    const output = document.getElementById('output');
    const progress = document.getElementById('progress');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    imageInput.addEventListener('change', async () => {
      const file = imageInput.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = async () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // Vorverarbeitung: Graustufen + Threshold
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i], g = data[i+1], b = data[i+2];
          const gray = 0.3 * r + 0.59 * g + 0.11 * b;
          const bw = gray > 140 ? 255 : 0; // Schwellenwert 140
          data[i] = data[i+1] = data[i+2] = bw;
        }
        ctx.putImageData(imageData, 0, 0);

        output.innerText = "Erkenne Textâ€¦";

        const worker = await Tesseract.createWorker({
          logger: m => { if (m.status === 'recognizing text') progress.value = m.progress; }
        });

        await worker.loadLanguage('eng');
        await worker.initialize('eng');
        await worker.setParameters({
          tessedit_pageseg_mode: 6,
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:/'
        });

        const { data: { text } } = await worker.recognize(canvas);
        await worker.terminate();

        output.innerText = "Erkannter Text:\n\n" + text + "\n\n" + "ðŸš€ Extrahierte Daten:\n" + extractFlightData(text);
      };
      img.src = URL.createObjectURL(file);
    });

    function extractFlightData(text) {
      const lines = text.split('\n').map(l => l.trim());
      let result = '';
      for (let line of lines) {
        if (line.includes('FLIGHT ID')) result += 'Flugnummer: ' + getAfter(line, 'FLIGHT ID') + '\n';
        if (line.includes('ORIG') && line.includes('DEST')) {
          const match = line.match(/[A-Z]{4}\/[A-Z]{4}/);
          if (match) {
            const [from, to] = match[0].split('/');
            result += `Abflug: ${from}\nZiel: ${to}\n`;
          }
        }
        if (line.includes('OUT')) result += 'Offblock: ' + getTime(line, 'OUT') + '\n';
        if (line.includes('OFF')) result += 'Takeoff: ' + getTime(line, 'OFF') + '\n';
        if (line.includes('ON'))  result += 'Landung: ' + getTime(line, 'ON') + '\n';
        if (line.includes('IN'))  result += 'Onblock: ' + getTime(line, 'IN') + '\n';
        if (line.includes('DATE')) result += 'Datum: ' + getAfter(line, 'DATE') + '\n';
      }
      return result || '(Keine bekannten Daten erkannt)';
    }

    function getAfter(line, key) {
      return line.split(key)[1]?.trim().split(' ')[0] || '';
    }

    function getTime(line, key) {
      const match = line.match(new RegExp(key + '\s*([0-9]{3,4}Z)', 'i'));
      return match ? match[1] : '';
    }
  </script>
</body>
</html>
